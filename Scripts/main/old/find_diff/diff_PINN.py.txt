103,124d102
<     def compute_divergence(self, cos_wind_angle, sin_wind_angle, x, y, z, output_params):
<         x.requires_grad_(True)
<         y.requires_grad_(True)
<         z.requires_grad_(True)
<         input_data = torch.hstack((x, y, z, cos_wind_angle, sin_wind_angle))
<         output = self(input_data)  # Model output
<         extracted_outputs = self.extract_output_parameters(output, output_params)
<         output_dict = {param: value for param, value in zip(output_params, extracted_outputs)}
<         u = output_dict.get('Velocity:0')
<         v = output_dict.get('Velocity:1')
<         w = output_dict.get('Velocity:2')
< 
<         def compute_gradients(tensor, coord):
<             grad_first = torch.autograd.grad(tensor, coord, grad_outputs=torch.ones_like(tensor), create_graph=True)[0]
<             return grad_first
< 
<         u_x = compute_gradients(u, x)
<         v_y = compute_gradients(v, y)
<         w_z = compute_gradients(w, z)
< 
<         return u_x, v_y, w_z
< 
147,257d124
<     def compute_RANS_component_f(self, cos_wind_angle, sin_wind_angle, x, y, z, rho, nu, output_params):
<         x.requires_grad_(True)
<         y.requires_grad_(True)
<         z.requires_grad_(True)
<         input_data = torch.hstack((x, y, z, cos_wind_angle, sin_wind_angle))
<         output = self(input_data)
<         extracted_outputs = self.extract_output_parameters(output, output_params)
<         output_dict = {param: value for param, value in zip(output_params, extracted_outputs)}
<         p = output_dict.get('Pressure')
<         u = output_dict.get('Velocity:0')
<         v = output_dict.get('Velocity:1')
<         w = output_dict.get('Velocity:2')
<         nu_t = output_dict.get('TurbVisc')
<         nu_eff = nu_t + nu
< 
<         def compute_gradients_and_second_order_gradients(tensor, coord):
<             grad_first = torch.autograd.grad(tensor, coord, grad_outputs=torch.ones_like(tensor), create_graph=True)[0]
<             grad_second = torch.autograd.grad(grad_first, coord, grad_outputs=torch.ones_like(grad_first), create_graph=True)[0]
<             return grad_first, grad_second
< 
<         def compute_gradients(tensor, coord):
<             grad_first = torch.autograd.grad(tensor, coord, grad_outputs=torch.ones_like(tensor), create_graph=True)[0]
<             return grad_first
< 
<         u_x, u_xx = compute_gradients_and_second_order_gradients(u, x)
<         u_y, u_yy = compute_gradients_and_second_order_gradients(u, y)
<         u_z, u_zz = compute_gradients_and_second_order_gradients(u, z)
<         p_x = compute_gradients(p, x)
<         v_x = compute_gradients(v, x)
<         v_xy = compute_gradients(v_x, y)
<         w_x = compute_gradients(w, x)
<         w_xz = compute_gradients(w_x, z)
< 
<         f = (u * u_x + v * u_y + w * u_z - (1 / rho) * p_x + nu_eff * (2 * u_xx) + nu_eff * (u_yy + v_xy) + nu_eff * (u_zz + w_xz))
< 
<         return f
< 
<     def compute_RANS_component_g(self, cos_wind_angle, sin_wind_angle, x, y, z, rho, nu, output_params):
<         x.requires_grad_(True)
<         y.requires_grad_(True)
<         z.requires_grad_(True)
<         input_data = torch.hstack((x, y, z, cos_wind_angle, sin_wind_angle))
<         output = self(input_data)
<         extracted_outputs = self.extract_output_parameters(output, output_params)
<         output_dict = {param: value for param, value in zip(output_params, extracted_outputs)}
<         p = output_dict.get('Pressure')
<         u = output_dict.get('Velocity:0')
<         v = output_dict.get('Velocity:1')
<         w = output_dict.get('Velocity:2')
<         nu_t = output_dict.get('TurbVisc')
<         nu_eff = nu_t + nu
< 
<         def compute_gradients_and_second_order_gradients(tensor, coord):
<             grad_first = torch.autograd.grad(tensor, coord, grad_outputs=torch.ones_like(tensor), create_graph=True)[0]
<             grad_second = torch.autograd.grad(grad_first, coord, grad_outputs=torch.ones_like(grad_first), create_graph=True)[0]
<             return grad_first, grad_second
< 
<         def compute_gradients(tensor, coord):
<             grad_first = torch.autograd.grad(tensor, coord, grad_outputs=torch.ones_like(tensor), create_graph=True)[0]
<             return grad_first
< 
<         v_x, v_xx = compute_gradients_and_second_order_gradients(v, x)
<         v_y, v_yy = compute_gradients_and_second_order_gradients(v, y)
<         v_z, v_zz = compute_gradients_and_second_order_gradients(v, z)
<         p_y = compute_gradients(p, y)
<         u_x = compute_gradients(u, x)
<         u_xy = compute_gradients(u_x, y)
<         w_y = compute_gradients(w, y)
<         w_yz = compute_gradients(w_y, z)
< 
<         g = (u * v_x + v * v_y + w * v_z - (1 / rho) * p_y + nu_eff * (v_xx + u_xy) + nu_eff * (2 * v_yy) + nu_eff * (v_zz + w_yz))
< 
<         return g
< 
<     def compute_RANS_component_h(self, cos_wind_angle, sin_wind_angle, x, y, z, rho, nu, output_params):
<         x.requires_grad_(True)
<         y.requires_grad_(True)
<         z.requires_grad_(True)
<         input_data = torch.hstack((x, y, z, cos_wind_angle, sin_wind_angle))
<         output = self(input_data)
<         extracted_outputs = self.extract_output_parameters(output, output_params)
<         output_dict = {param: value for param, value in zip(output_params, extracted_outputs)}
<         p = output_dict.get('Pressure')
<         u = output_dict.get('Velocity:0')
<         v = output_dict.get('Velocity:1')
<         w = output_dict.get('Velocity:2')
<         nu_t = output_dict.get('TurbVisc')
<         nu_eff = nu_t + nu
< 
<         def compute_gradients_and_second_order_gradients(tensor, coord):
<             grad_first = torch.autograd.grad(tensor, coord, grad_outputs=torch.ones_like(tensor), create_graph=True)[0]
<             grad_second = torch.autograd.grad(grad_first, coord, grad_outputs=torch.ones_like(grad_first), create_graph=True)[0]
<             return grad_first, grad_second
< 
<         def compute_gradients(tensor, coord):
<             grad_first = torch.autograd.grad(tensor, coord, grad_outputs=torch.ones_like(tensor), create_graph=True)[0]
<             return grad_first
< 
<         w_x, w_xx = compute_gradients_and_second_order_gradients(w, x)
<         w_y, w_yy = compute_gradients_and_second_order_gradients(w, y)
<         w_z, w_zz = compute_gradients_and_second_order_gradients(w, z)
<         p_z = compute_gradients(p, z)
<         u_x = compute_gradients(u, x)
<         u_xz = compute_gradients(u_x, z)
<         v_y = compute_gradients(v, y)
<         v_yz = compute_gradients(v_y, z)
< 
<         h = (u * w_x + v * w_y + w * w_z - (1 / rho) * p_z + nu_eff * (w_xx + u_xz) + nu_eff * (w_yy + v_yz) + nu_eff * (2 * w_zz))
< 
<         return h 
< 
